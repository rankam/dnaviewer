<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 10px sans-serif;
}

.arc path {
  stroke: #fff;
}

.hideTableRow {
  display: none;
}

.legend {
  text-transform: capitalize;
}

</style>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

var width = 960,
    height = 500,
    radius = Math.min(width, height) / 2;

var color = d3.scale.category20()

var arc = d3.svg.arc()
    .outerRadius(function(d) {
      if (d.data.bases == 'undefined') {
        return radius - 10
      } else {
        return radius - 0  
      }
    })
    .innerRadius(function(d) {
      if (d.data.bases == 'undefined') {
        return radius - 15
      } else {
        return radius - 30  
      }
    });
      

var pie = d3.layout.pie()
    .sort(null)
    .value(function(d) { return d.size; });

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

d3.json("/fixtures/dnamolecule.json", function(error, dd) {

  data = []

  dd.dnafeatures.forEach(function(d,i) {
    
    dnafeature = {};
    dnafeature.name = d.dnafeature.name;
    dnafeature.size = d.dnafeature.length;
    dnafeature.bases = d.dnafeature.pattern.bases;
    dnafeature.start = parseFloat(d.start)
    dnafeature.end = d.end;
    dnafeature.display = "";
    data.push(dnafeature);

  })

data.sort(function(a, b) {
    return parseFloat(a.start) - parseFloat(b.start);
});


for (i in data) {
  if (i  % 2 === 1) {
    if ( data[i-1].start + data[i-1].size + 1 != data[i].start ) {
      nullFeature = {}
      nullFeature.name = ''
      if (i-1 == 0) {
        nullFeature.start = data[i-1].start - (data[i-1].end - data[i-1].size)
      } else {
        nullFeature.start = data[i-1].end + 1
      }
      nullFeature.end = data[i].start - 1
      nullFeature.size = nullFeature.end - nullFeature.start
      nullFeature.bases = 'undefined'
      nullFeature.display = "none"
      data.splice(i-1,0,nullFeature)
    }
  } 
}

blah = []
data.forEach(function(d) {
  blah.push(d.start)
})
console.log(blah)

  var g = svg.selectAll(".arc")
      .data(pie(data))
    .enter().append("g")
      .attr("class", "arc")


  g.append("path")
      .attr("d", arc)
      .attr("class", function(d) { return d.data.bases })
      .style("fill", function(d,i) { 
        if (d.data.name == '') {
          return "black"
        } else {
          return color(i); 
        }
      });


// create new dataset with nullFeatures removed so that the black areas of the chart do not show up in the legend
var legendData = [];
data.forEach(function(d, i) {

  if (d.bases != "undefined") {

    // keep the original indexes so that the legend color matches the chart
    d.colorIndex = i

    legendData.push(d)
  }
})

var legend = d3.select("body").append("svg")
  .attr("class", "legend")
  .attr("width", radius)
  .attr("height", radius * 2)
  .selectAll("g")
  .data(legendData)
  .enter().append("g")
  .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

legend.append("rect")
  .attr("width", 18)
  .attr("height", 18)
  .style("fill", function(d, i) { return color(d.colorIndex); });

legend.append("text")
  .attr("x", 24)
  .attr("y", 9)
  .attr("dy", ".35em")
  .text(function(d) { return d.name; })


// The table generation function
function tabulate(data, columns) {
    var table = d3.select("body").append("table")
            .attr("style", "margin-left: 250px"),
        thead = table.append("thead"),
        tbody = table.append("tbody");

    // append the header row
    thead.append("tr")
        .selectAll("th")
        .data(columns)
        .enter()
        .append("th")
            .text(function(column) { return column; });

    // create a row for each object in the data
    var rows = tbody.selectAll("tr")
        .data(data)
        .enter()
        .append("tr")
        .attr("class", function(d) {
          if (d.name == "") {
            return "hidden-row"
          } else {
            return "visibile-row"
          }
        })

    // create a cell in each row for each column
    var cells = rows.selectAll("td")
        .data(function(row) {
            return columns.map(function(column) {
                return {column: column, value: row[column]};
            });
        })
        .enter()
        .append("td")
        .attr("style", "font-family: Courier") // sets the font style
            .html(function(d) { return d.value; })
        .attr("class", function(d) {
          if (d.value == "") {
            return "hideTableRow"
          } else {
            return "showTableRow"
          }
        })
    return table;
}

// render the table
 var peopleTable = tabulate(data, ["name", "size", "start", "end"]);
 d3.selectAll(".hidden-row")
  .style("display", "none")


});

</script>